<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Heap. Extract min</title>
</head>
<body>

<canvas id="canvas" width="1024" height="400">C A N V A S</canvas>
<canvas id="legend" width="1024" height="120">legend</canvas>
<canvas id="minvalue" width="1024" height="100">lmao</canvas>
<div>
    <label for="vertexNum">Vertex number: </label><input id="vertexNum" value="31">
    <button id="generate">Generate</button>
</div>
<div>
    <button id="start">Start visualisation</button>
    <button id="nextStep">Next step</button>
    <button id="finish">Finish visualisation</button>

</div>
<script lang="text/javascript">
    // Main canvas, where heap is drawn
    var canvas = document.getElementById("canvas");
    var ctx = canvas.getContext('2d');
    // Canvas for text "Extracted values..."
    var text = document.getElementById("minvalue");
    var textCtx = text.getContext('2d');
    // Canvas for map legend
    var legend = document.getElementById("legend");
    var legendCtx = legend.getContext('2d');
    // Button that start visualisation
    var startButton = document.getElementById("start");
    textCtx.font = "30px Georgia";
    legendCtx.font = "20px Arial";


    // Array of values, that heap contains
    var heap = [];
    // Array of coordinates of vertex in heap
    var coords = [];
    // Index of elements, that now are swapping (need for animation)
    var swapped = [];
    // Radius of vertex in heap
    var circleRadius = 30;
    // True after pressing at button "Start visualisation" and before the end of animation
    var startedExtract = false;
    // List of extracted values from current heap
    var extractedValues = [];
    // True if there are some animation right now
    var moving = false;


    function clearCanvas(ctx, canvas) {
        ctx.fillStyle = "white";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }


    function swap(a, i, j) {
        var temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }

    // Check if first index can be father of second and contrariwise
    function isNeighbours(i, j) {
        return (~~(i / 2) === j) || (~~(j / 2) === i);
    }

    // Calculate distance between two point
    function distance(a, b) {
        return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2))
    }

    // Calculates the coordinates of a point on a circle
    // from which you want to draw an edge to another vertex
    function getPointOnCircle(a, b, dist) {
        var cos = (a.x - b.x) / distance(a, b),
            sin = (a.y - b.y) / distance(a, b),
            x = a.x - dist * cos,
            y = a.y - dist * sin;
        return {x: x, y: y}
    }

    // Main function, that draw heap
    function draw(animate) {
        ctx.fillStyle = "black";
        ctx.font = "20px Georgia";

        // Draw vertex with/within border
        function drawCircle(ctx, x, y, value, color, border) {
            border = border | 0;

            ctx.strokeStyle = "blue";
            ctx.beginPath();
            ctx.arc(x, y, circleRadius + border, 0, 2 * Math.PI, false);
            ctx.stroke();

            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, circleRadius, 0, 2 * Math.PI, false);
            ctx.fill();

            ctx.fillStyle = "black";
            ctx.fillText((value < 10 ? " " : "") + value, x - 10, y + 8);
        }

        function getColor(son, parent) {
            return parent === null ? "yellow" : son > parent ? "#98FB98" : son === parent ? "yellow" : "red"
        }

        /** For the 1st draw we need to calculate coordinates of vertices
         *  We will arrange the vertices as follows.
         *  The coordinates Y are considered trivial - each new heap level increases
         *  the value of Y by a constant value.
         *  If the current vertex is the left son,
         *  then the X coordinate will be in the middle
         *  between the left border and the X value of the parent.
         *  Otherwise, in the middle between the value of X and the right border of the parent.
         **/
        function calculateAndDrawVertex() {
            // The heap is more convenient to fill with the 1st index
            coords = [null, {x: canvas.width / 2, y: 50, left: 0, right: canvas.width}];
            drawCircle(ctx, coords[1].x, coords[1].y, heap[1], "yellow");

            for (var i = 2; i < heap.length; i++) {
                var parent = ~~(i / 2);
                var x, y, left, right;
                if (parent * 2 === i) {
                    left = coords[parent].left;
                    right = coords[parent].x;
                } else {
                    left = coords[parent].x;
                    right = coords[parent].right;
                }
                x = (left + right) / 2;
                y = coords[parent].y + 2 * circleRadius;
                coords[i] = {x: x, y: y, left: left, right: right};
                drawCircle(ctx, x, y, heap[i], getColor(heap[i], heap[parent]));
            }
        }

        // If we redraw canvas, coordinates have already been calculated
        function drawVertex() {
            for (var i = 1; i < heap.length; i++) {
                drawCircle(ctx, coords[i].x, coords[i].y, heap[i], getColor(heap[i], heap[~~(i / 2)]),
                    swapped.indexOf(i) === -1 ? 0 : 5)
            }
        }

        // Draw all edges in heap
        function drawArrows() {

            function drawArrow(a, b) {


                ctx.beginPath();
                var startPoint = getPointOnCircle(a, b, circleRadius),
                    endPoint = getPointOnCircle(b, a, circleRadius);
                ctx.moveTo(startPoint.x, startPoint.y);
                ctx.lineTo(endPoint.x, endPoint.y);
                ctx.stroke()
            }

            // Here are a few conditions for the edges to swap at the beginning of the animation
            for (var i = heap.length - 1; i > 1; i--) {
                var parent = ~~(i / 2);
                if (swapped.length === 0 || isNeighbours(swapped[0], swapped[1])) {
                    // Conditions for classic sift down
                    if (swapped.indexOf(i) === -1 && swapped.indexOf(parent) !== -1)
                        parent = parent === swapped[0] ? swapped[1] : swapped[0];
                } else {
                    // Conditions for swapping  not adjacent vertices
                    if (i === 1) {
                        parent = swapped[0] === i ? swapped[1] : swapped[0];
                    } else {
                        parent = parent === swapped[0] ?
                            swapped[1] : parent === swapped[1] ? swapped[0] : parent;
                    }
                }
                drawArrow(coords[i], coords[parent]);
            }
        }

        function drawScheme() {
            clearCanvas(legendCtx, legend);
            legendCtx.fillStyle = "black";
            legendCtx.fillText("Explanatory notes: ", 0, 50);


            drawCircle(legendCtx, 270, 35, "", "#98FB98");
            legendCtx.fillText("If current vertex is greater", 170, 90);
            legendCtx.fillText("than parent vertex", 170, 110);

            drawCircle(legendCtx, 550, 35, "", "yellow");
            legendCtx.fillText("If current vertex is equal", 450, 90);
            legendCtx.fillText("to parent vertex", 450, 110);

            drawCircle(legendCtx, 800, 35, "", "red");
            legendCtx.fillText("If current vertex is lower", 700, 90);
            legendCtx.fillText("than parent vertex", 700, 110);


        }


        if (!animate) calculateAndDrawVertex(); else  drawVertex();
        drawArrows();
        drawScheme();
    }

    function redraw(animate) {
        clearCanvas(ctx, canvas);
        draw(animate)
    }


    // Generate random heap
    function generate() {
        // N should be natural number from 1 to 31
        // Heap with size bigger than 31 is hard to represent
        // Because then it is necessary to reduce the radius of the circles and it will become unreadable
        var n = Math.abs(parseInt(document.getElementById("vertexNum").value));
        if (isNaN(n) || n > 31 || n === 0) {
            n = 31;
        }
        document.getElementById("vertexNum").value = n;
        function nextInt() {
            return Math.random() * 10 | 0
        }

        heap = [null];
        for (var i = 1; i <= n; i++) {
            heap[i] = heap[~~(i / 2)] + nextInt();
        }
        redraw(false)
    }

    // If right now occurs some animation
    // Finish it immediately by nextStep
    // And set flag finished, which affects the operation of function processOrder
    function finishVisualisation() {
        if (!startedExtract) return;
        if (moving) {
            nextStep = true;
            var timer = setInterval(function () {
                if (!nextStep) {
                    finished = true;
                    clearInterval(timer);
                }
            }, 50);
        } else finished = true;
    }

    // If right now occurs animation, finish it immediately
    // and draw new heap
    document.getElementById("generate").addEventListener("click", function () {
        if (startedExtract) {
            finishVisualisation();
            var timer = setInterval(function () {
                if (!startedExtract) {
                    extractedValues = [];
                    clearInterval(timer);
                    generate()
                }
            }, 50)
        } else {
            extractedValues = [];
            generate();
        }
    });


    var paused = false,
        nextStep = false,
        finished = false;
    // Start visualization
    startButton.addEventListener("click", function () {
        if (paused) {
            startButton.firstChild.data = "Pause visualisation";
            paused = false;
            return
        }
        if (startedExtract) {
            startButton.firstChild.data = "Resume visualisation";
            paused = true;
            return;
        }
        // To avoid errors
        if (heap.length === 1) return;

        startedExtract = true;
        startButton.firstChild.data = "Pause visualisation";
        var order = [];
        var dateStopped = Date.now() - 500;

        // Animate swap of vertices
        function swapVertices(i, j, deleteV) {
            var p1 = {x: coords[i].x, y: coords[i].y};
            var p2 = {x: coords[j].x, y: coords[j].y};
            var deltaX = (p2.x - p1.x) / 30;
            var deltaY = (p2.y - p1.y) / 30;
            moving = true;
            swapped = [i, j];

            var timer = setInterval(function () {
                if (distance(coords[i], p2) < 5 || nextStep) {
                    nextStep = false;
                    coords[i] = p1;
                    coords[j] = p2;
                    swap(heap, i, j);
                    swapped = [];
                    if (deleteV) {
                        clearCanvas(textCtx, text);
                        textCtx.fillStyle = "black";
                        extractedValues.push(heap.pop());
                        textCtx.fillText("Extracted values: " + extractedValues, canvas.width / 2, 50);
                        coords.pop();
                    }
                    moving = false;
                    dateStopped = Date.now();
                    clearInterval(timer)
                } else {
                    //At each step, we increase the coordinates by a uniform value for smooth animation
                    coords[i].x += deltaX;
                    coords[i].y += deltaY;
                    coords[j].x -= deltaX;
                    coords[j].y -= deltaY;
                }
                redraw(true)
            }, 50)
        }

        // However calculating of sift down process is much faster then visualization
        // this function will wait the end of current animation, wait 0.5 sec and start next animation
        function processOrder() {
            var timer = setInterval(function () {
                if (finished) {
                    paused = false;
                    finished = false;
                    startedExtract = false;
                    for (var i = 0; i < order.length; i++) {
                        swap(heap, order[i].i, order[i].j);
                    }
                    order = [];
                    redraw(true);
                }
                if (!moving && paused && nextStep || (!moving && !paused && Date.now() - dateStopped >= 500)) {
                    nextStep = false;
                        if (order.length !== 0) {
                            var indices = order.shift();
                            swapVertices(indices.i, indices.j, indices.deleteV);
                        } else {
                            startedExtract = false;
                            startButton.firstChild.data = "Start visualisation";
                            clearInterval(timer);
                        }
                    }
                }
            )
        }

        processOrder();


        // Extract minimum value from heap and restores heap properties. O(log n)
        function siftDown() {
            var i = 1;
            // Value in original array "heap" swapped in the end of animation
            // so we need copy of heap array, to swap without waiting
            var H = heap.slice(0);
            // Swap first and last element in heap and delete last
            swap(H, 1, H.length - 1);
            H.pop();
            // Visualize it
            order.push({i: i, j: heap.length - 1, deleteV: true});

            while (i < H.length) {
                // If both sons are exist
                if (i * 2 + 1 < H.length) {
                    // And al least one son is lower then current vertex
                    if (H[i] > Math.min(H[i * 2], H[i * 2 + 1])) {
                        // Swap with min son
                        var index = H[i * 2] < H[i * 2 + 1] ? i * 2 : i * 2 + 1;
                        order.push({i: i, j: index, deleteV: false});
                        swap(H, i, index);
                        i = index;
                        // otherwise heap properties are restored
                    } else break;
                } else {
                    // If there are only one son and him value is lower than current, swap
                    if (i * 2 < H.length && H[i * 2] < H[i]) {
                        order.push({i: i, j: i * 2});
                        swap(H, i, i * 2);
                        i *= 2;
                        // otherwise heap is balanced
                    } else break;
                }

            }
        }

        processOrder();
        siftDown();

    });

    document.getElementById("nextStep").addEventListener("click", function () {
        nextStep = true;
    });


    document.getElementById("finish").addEventListener("click", function () {
        finishVisualisation();
    });

    generate()

</script>
</body>
</html>